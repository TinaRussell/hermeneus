;;; hrm-storage.el --- -*- lexical-binding: t -*-

(require 'eieio)
(require 'eieio-base)
(require 'cl-generic)

(defvar hrm-storage-file (concat "lsj-cache" (when (executable-find "gzip") ".gz")))

(defcustom hrm-storage-dir (expand-file-name "var/hermeneus" user-emacs-directory)
  "Directory in which to store files generated by Hermeneus.
At present, this means where to store the Hermeneus lexicon
cache. If you set this outside Customize, ensure that the
directory exists (creating it if necessary), and set
‘hrm-storage-path’ to the value of calling ‘expand-file-name’
with the new ‘hrm-storage-dir’ value followed by
‘hrm-storage-file’ as arguments."
  :type 'directory
  :tag "Hermeneus — storage directory"
  :group 'hermeneus
  :set (lambda (symbol value)
         (unless (file-exists-p (directory-file-name value))
           (make-directory (directory-file-name value) t))
         (set-default symbol value)
         (setq hrm-storage-path
               (expand-file-name hrm-storage-file value))))

(defvar hrm-storage-path (expand-file-name hrm-storage-file hrm-storage-dir))

(defclass hrm-word ()
  ((key :type string
        :initarg :key
        :initform "")
   (id :type integer
       :initarg :id
       :initform 0)
   (loc :type (or cons null)
        :initarg :loc
        :initform nil))
  :documentation "A Hermeneus object to represent one word.")

(defclass hrm-lexicon (eieio-persistent)
  ((initialized-p :type boolean
                  :initarg :initialized-p
                  :initform nil)
   (entries :type hash-table
            :initarg :entries
            :initform (make-hash-table :size 116493 :test 'equal))
   ;; I have absolutely zero clue why (file :initform hrm-storage-path)
   ;; results in an “invalid-slot-type” error, but this doesn’t:
   (file :initform (symbol-value 'hrm-storage-path))
   (file-header-line :initform ";; Hermeneus lexicon object"))
  :documentation "A Hermeneus object to represent a lexicon of words.")

(cl-defmethod make-instance ((cls (subclass hrm-lexicon)) &rest slots)
  "When making a ‘hrm-lexicon’ object, try to read it from a file.
(The file’s path can be passed as a “:file” keyword argument, but
otherwise defaults to ‘hrm-storage-path’.) If the file doesn’t exist,
or otherwise can’t be used, move on."
  (let ((path (or (plist-get slots :file)
                  hrm-storage-path)))
    (or (and (file-exists-p path)
             (eieio-persistent-read path cls t))
        (cl-call-next-method))))

(cl-defmethod initialize-instance :after ((this hrm-lexicon) &rest slots)
  "After initializing a ‘hrm-lexicon’ object, populate its ‘entries’
  hash-table with word-objects from the LSJ."
  (let ((entries (oref this entries)))
    ;; Don’t bother scanning the LSJ for entries if the
    ;; ‘entries’ hash-table is already populated, or if
    ;; slot ‘initialize-p’ is nil.
    (unless (or (eq (hash-table-count entries) (hash-table-size entries))
                (oref this initialized-p))
      (oset this entries (hrm-scan-entries))
      (oset this initialized-p t)
      (eieio-persistent-save this))))

(defvar hrm-lsj (hrm-lexicon nil))

(provide 'hrm-storage)

;;; hrm-storage.el ends here
